<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tufin Topology (Ant Design)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Ant Design CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@5/dist/reset.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@5/dist/antd.min.css" />

  <!-- React + ReactDOM + Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.26.4/babel.min.js"></script>

  <!-- Day.js + plugins (must load BEFORE AntD JS) -->
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/advancedFormat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/customParseFormat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/localeData.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/weekOfYear.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/weekYear.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/quarterOfYear.js"></script>
  <script>
    dayjs.extend(dayjs_plugin_advancedFormat);
    dayjs.extend(dayjs_plugin_customParseFormat);
    dayjs.extend(dayjs_plugin_localeData);
    dayjs.extend(dayjs_plugin_weekOfYear);
    dayjs.extend(dayjs_plugin_weekYear);
    dayjs.extend(dayjs_plugin_quarterOfYear);
  </script>

  <!-- Ant Design UMD -->
  <script src="https://cdn.jsdelivr.net/npm/antd@5/dist/antd.min.js"></script>

  <style>
    html, body, #root { height: 100%; margin: 0; }
    .topology-image-wrap {
      position: relative; border: 1px solid #f0f0f0; border-radius: 8px;
      min-height: 360px; overflow: hidden;
      background: repeating-conic-gradient(from 0deg, #0000 0deg 90deg, rgba(0,0,0,.02) 90deg 180deg);
    }
    .topology-image-wrap img {
      display: block; max-width: 100%; user-select: none; cursor: grab;
      transform-origin: center center;
    }
    .overlay-center {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color:#999; font-weight:600;
    }
    pre.json {
      margin: 0; padding: 12px; background: #0b1220; color: #e5eef9;
      border-radius: 8px; overflow:auto; font-size: 12px; line-height: 1.4;
    }
    .device-tags .ant-tag { margin-bottom: 4px; }
    .approved-list .ant-list-item { align-items: flex-start; }
    .toolbar-gap > * { margin-right: 8px; }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const {
      ConfigProvider, theme, Layout, Menu, Space, Typography, Form, Input, Button, Card,
      Row, Col, message, Modal, Select, Tag, Badge, Table, List, Popconfirm, Tooltip,
      Collapse, Switch
    } = antd;

    const { Header, Content, Footer } = Layout;
    const { Text } = Typography;

    /* ===== Header ===== */
    function HeaderNav({ currentPath, onToggleTheme, isDark }) {
      const selectedKey = currentPath === '/tags' ? 'tags' : 'topology';
      return (
        <Header style={{ position:'sticky', top:0, zIndex:1000, display:'flex', alignItems:'center' }}>
          <div style={{ color:'#1677ff', fontWeight:700, marginRight:16 }}>Tufin</div>
          <Menu
            theme="dark"
            mode="horizontal"
            selectedKeys={[selectedKey]}
            items={[
              { key:'topology', label:<a href="/">Topology</a> },
              { key:'tags', label:<a href="/tags">Tags & Mapping</a> },
              { key:'approved', label:<a href="#approved">Approved Networks</a> },
            ]}
            style={{ flex:1 }}
          />
          <Space>
            <Text style={{ color:'#fff' }}>Dark</Text>
            <Switch checked={isDark} onChange={onToggleTheme}/>
          </Space>
        </Header>
      );
    }

    /* ===== Taxonomy Hook ===== */
    function useTaxonomy() {
      const [tax, setTax] = useState(null);
      useEffect(() => {
        fetch('/api/tag-taxonomy').then(r=>r.json()).then(setTax).catch(()=>setTax(null));
      }, []);
      const opts = (arr)=> (arr||[]).map(v => ({ label:v, value:v }));
      return {
        tax,
        envOpts: opts(tax?.environment),
        buOpts: opts(tax?.businessUnit),
        dataOpts: opts(tax?.dataSensitivity),
        zoneOpts: opts(tax?.trustZone),
        appOpts: opts(tax?.application),
        compOpts: opts(tax?.compliance),
      };
    }

    /* ===== Tag Modal ===== */
    function TagModal({ open, onCancel, onSaved, prefillCidr, prefillTags }) {
      const { envOpts, buOpts, dataOpts, zoneOpts, appOpts, compOpts } = useTaxonomy();
      const [form] = Form.useForm();

      useEffect(()=>{
        form.resetFields();
        form.setFieldsValue({ cidr: prefillCidr || '' });
        (prefillTags||[]).forEach(tag=>{
          const [k,v] = String(tag).split(':');
          const map = { Env:'env', BU:'bu', DataClassification:'data', Zone:'zone', App:'app', Service:'app', Compliance:'comp' };
          const field = map[k];
          if (field) form.setFieldValue(field, v);
        });
      }, [open]);

      const onFinish = async (vals) => {
        const cidr = (vals.cidr||'').trim();
        const tags = [];
        if (vals.env) tags.push(`Env:${vals.env}`);
        if (vals.bu) tags.push(`BU:${vals.bu}`);
        if (vals.data) tags.push(`DataClassification:${vals.data}`);
        if (vals.zone) tags.push(`Zone:${vals.zone}`);
        if (vals.app) tags.push(`App:${vals.app}`);
        if (vals.comp) tags.push(`Compliance:${vals.comp}`);
        try {
          if (/^(\d+\.){3}\d+$/.test(cidr)) {
            await fetch('/api/approved-networks/tag-by-ip', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ ip: cidr, tags }) });
          } else {
            await fetch('/api/approved-networks', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ cidr, tags }) });
          }
          message.success('Saved');
          onSaved?.();
        } catch(e) {
          message.error('Failed to save tags');
        }
      };

      return (
        <Modal title="Tag Network" open={open} onCancel={onCancel} onOk={()=>form.submit()}>
          <Form form={form} layout="vertical" onFinish={onFinish}>
            <Form.Item label="Network (CIDR or IP)" name="cidr" rules={[{ required:true, message:'Enter CIDR or IP' }]}>
              <Input placeholder="10.0.0.0/24 or 10.0.0.5" />
            </Form.Item>
            <Row gutter={12}>
              <Col span={12}><Form.Item label="Environment" name="env"><Select allowClear options={envOpts} /></Form.Item></Col>
              <Col span={12}><Form.Item label="Business Unit" name="bu"><Select allowClear options={buOpts} /></Form.Item></Col>
              <Col span={12}><Form.Item label="Data Sensitivity" name="data"><Select allowClear options={dataOpts} /></Form.Item></Col>
              <Col span={12}><Form.Item label="Trust Zone" name="zone"><Select allowClear options={zoneOpts} /></Form.Item></Col>
              <Col span={12}><Form.Item label="Application/Service" name="app"><Select allowClear options={appOpts} /></Form.Item></Col>
              <Col span={12}><Form.Item label="Compliance" name="comp"><Select allowClear options={compOpts} /></Form.Item></Col>
            </Row>
          </Form>
        </Modal>
      );
    }

    /* ===== Approved Networks Card ===== */
    function ApprovedNetworksCard({ onChanged }) {
      const [items, setItems] = useState([]);
      const [adding, setAdding] = useState('');
      const [openTag, setOpenTag] = useState(false);
      const [prefill, setPrefill] = useState({ cidr:'', tags:[] });

      const load = async () => {
        const data = await fetch('/api/approved-networks').then(r=>r.json());
        setItems(data.items || []);
      };
      useEffect(()=>{ load(); }, []);

      const addQuick = async () => {
        const cidr = adding.trim();
        if (!cidr) return;
        try {
          await fetch('/api/approved-networks', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ cidr }) });
          setAdding(''); await load(); onChanged?.();
          message.success('Added');
        } catch { message.error('Failed to add'); }
      };

      const remove = async (id) => {
        await fetch('/api/approved-networks/'+id, { method:'DELETE' });
        await load(); onChanged?.();
        message.success('Deleted');
      };

      const edit = (entry) => {
        setPrefill({ cidr: entry.cidr, tags: entry.tags || [] });
        setOpenTag(true);
      };

      return (
        <>
          <Card id="approved" title="Approved Networks" extra={
            <Space>
              <Input value={adding} onChange={(e)=>setAdding(e.target.value)} placeholder="CIDR or IP" style={{ width:220 }}/>
              <Button type="primary" onClick={addQuick}>Add</Button>
              <Button onClick={()=>{ setPrefill({cidr:'', tags:[]}); setOpenTag(true); }}>Tag with Details</Button>
            </Space>
          }>
            <List
              className="approved-list"
              itemLayout="horizontal"
              dataSource={items}
              locale={{ emptyText: 'No approved networks yet' }}
              renderItem={(it)=>(
                <List.Item
                  actions={[
                    <a key="edit" onClick={()=>edit(it)}>Edit</a>,
                    <Popconfirm key="del" title="Delete?" onConfirm={()=>remove(it.id)}><a>Delete</a></Popconfirm>
                  ]}
                >
                  <List.Item.Meta
                    title={<Space wrap>
                      <Text code>{it.cidr}</Text>
                      {(it.tags||[]).map(t => <Tag key={t} color="geekblue">{t}</Tag>)}
                    </Space>}
                    description={(!it.tags || !it.tags.length) ? <Text type="secondary">No tags</Text> : null}
                  />
                </List.Item>
              )}
            />
          </Card>

          <TagModal
            open={openTag}
            onCancel={()=>setOpenTag(false)}
            prefillCidr={prefill.cidr}
            prefillTags={prefill.tags}
            onSaved={async ()=>{ setOpenTag(false); await load(); onChanged?.(); }}
          />
        </>
      );
    }

    /* ===== Devices Table ===== */
    function DevicesTable({ rows, onTag }) {
      const cols = [
        { title:'Hop', dataIndex:'hop', width:70 },
        { title:'Device', dataIndex:'device', render:(v, rec)=>(
          <Space>
            <Text>{v}</Text>
            {rec.approved && <Badge status="success" text="Approved" />}
          </Space>
        )},
        { title:'Type', dataIndex:'type', width:160 },
        { title:'Interface', dataIndex:'iface', width:160 },
        { title:'Notes', dataIndex:'notes' },
        { title:'Tags', dataIndex:'tags', render:(ts)=>(<Space wrap className="device-tags">{(ts||[]).map(t=><Tag key={t}>{t}</Tag>) || <Text type="secondary">—</Text>}</Space>)},
        { title:'Actions', key:'act', width:140, render:(_, rec)=>(
          <Button type="link" onClick={()=>onTag(rec)}>Tag Network</Button>
        )}
      ];
      return <Table size="small" columns={cols} dataSource={rows} rowKey={(r,i)=>String(i)} pagination={{ pageSize:8 }} />;
    }

    /* ===== Topology Page ===== */
    function TopologyPage() {
      const [form] = Form.useForm();
      const [loading, setLoading] = useState(false);
      const [json, setJson] = useState(null);
      const [devices, setDevices] = useState([]);
      const [imgSrc, setImgSrc] = useState('');
      const [imgReady, setImgReady] = useState(false);

      const [tagOpen, setTagOpen] = useState(false);
      const [tagPrefill, setTagPrefill] = useState({ cidr:'', tags:[] });

      // zoom/pan
      const imgRef = useRef(null);
      const [scale, setScale] = useState(1);
      const [offset, setOffset] = useState({ x:0, y:0 });
      const dragRef = useRef({ dragging:false, sx:0, sy:0, ox:0, oy:0 });

      const doQuery = async (values) => {
        const { source, destination, service } = values;
        setLoading(true); setImgReady(false);
        setScale(1); setOffset({x:0,y:0});

        const imgURL = `/api/topology-image?source=${encodeURIComponent(source)}&destination=${encodeURIComponent(destination)}&service=${encodeURIComponent(service||'')}`;
        setImgSrc(imgURL);

        try {
          const r = await fetch('/api/topology-path-with-devices', {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ source, destination, service })
          });
          const payload = await r.json();
          if (!r.ok) throw new Error(payload?.details || 'API error');
          setJson(payload.data || {});
          setDevices(payload.devices || []);
        } catch(e) {
          message.error(e.message || 'Query failed');
          setJson({ error: e.message || 'Query failed' });
          setDevices([]);
        } finally {
          setLoading(false);
        }
      };

      const onSubmit = ()=>form.validateFields().then(doQuery);
      const swap = ()=>{
        const s = form.getFieldValue('source');
        const d = form.getFieldValue('destination');
        form.setFieldsValue({ source:d, destination:s });
      };

      const wheelZoom = (e)=>{
        e.preventDefault();
        const delta = e.deltaY < 0 ? 0.1 : -0.1;
        setScale(s => Math.max(0.4, Math.min(4, s + delta)));
      };
      const mDown = (e)=>{
        dragRef.current = { dragging:true, sx:e.clientX, sy:e.clientY, ox:offset.x, oy:offset.y };
        if (imgRef.current) imgRef.current.style.cursor = 'grabbing';
      };
      const mUp = ()=>{
        dragRef.current.dragging = false;
        if (imgRef.current) imgRef.current.style.cursor = 'grab';
      };
      const mMove = (e)=>{
        if (!dragRef.current.dragging) return;
        const dx = e.clientX - dragRef.current.sx;
        const dy = e.clientY - dragRef.current.sy;
        setOffset({ x: dragRef.current.ox + dx, y: dragRef.current.oy + dy });
      };

      const onTagRow = (rec)=>{
        const ip = (rec.ip || '').trim();
        setTagPrefill({ cidr: ip ? `${ip}/32` : '', tags: rec.tags || [] });
        setTagOpen(true);
      };

      // Refresh devices after tags saved using current form values
      const refreshDevicesFromForm = async ()=>{
        const vals = form.getFieldsValue();
        if (!vals?.source || !vals?.destination) return;
        try {
          const r = await fetch('/api/topology-path-with-devices', {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ source: vals.source, destination: vals.destination, service: vals.service })
          });
          const payload = await r.json();
          if (r.ok) setDevices(payload.devices || []);
        } catch {}
      };

      return (
        <Space direction="vertical" size="large" style={{ display:'flex', padding:'16px' }}>
          <Card title="Topology Query" extra={
            <Space className="toolbar-gap">
              <Button onClick={swap}>Swap</Button>
              <Button onClick={()=>{ form.resetFields(); setImgSrc(''); setJson(null); setDevices([]); }}>Clear</Button>
            </Space>
          }>
            <Form
              form={form}
              layout="inline"
              onFinish={doQuery}
              initialValues={{ source:'', destination:'', service:'' }}
            >
              <Form.Item name="source" label="Source" rules={[{required:true, message:'Required'}]}>
                <Input placeholder="10.0.0.1" style={{ width:220 }}/>
              </Form.Item>
              <Form.Item name="destination" label="Destination" rules={[{required:true, message:'Required'}]}>
                <Input placeholder="10.0.2.5" style={{ width:220 }}/>
              </Form.Item>
              <Form.Item name="service" label="Service">
                <Input placeholder="tcp/80, 443, udp/53…" style={{ width:220 }}/>
              </Form.Item>
              <Form.Item>
                <Button type="primary" loading={loading} onClick={onSubmit}>Run Query</Button>
              </Form.Item>
            </Form>
          </Card>

          <Row gutter={16}>
            <Col xs={24} lg={14}>
              <Card
                title="Topology Image"
                extra={
                  <Space>
                    <Tooltip title="Zoom In"><Button onClick={()=>setScale(s=>Math.min(4,s+0.15))}>＋</Button></Tooltip>
                    <Tooltip title="Zoom Out"><Button onClick={()=>setScale(s=>Math.max(0.4,s-0.15))}>－</Button></Tooltip>
                    <Tooltip title="Reset View"><Button onClick={()=>{ setScale(1); setOffset({x:0,y:0}); }}>⤾</Button></Tooltip>
                    <Button onClick={()=>{
                      if (!imgSrc) return;
                      const a=document.createElement('a'); a.href=imgSrc; a.download=`topology_${Date.now()}.png`; a.click();
                    }}>Download</Button>
                  </Space>
                }
              >
                <div className="topology-image-wrap"
                    onWheel={wheelZoom}
                    onMouseDown={mDown}
                    onMouseUp={mUp}
                    onMouseMove={mMove}>
                  {!imgSrc && <div className="overlay-center">No image yet</div>}
                  {!!imgSrc && (
                    <>
                      {!imgReady && <div className="overlay-center">Loading image…</div>}
                      <img
                        ref={imgRef}
                        src={imgSrc}
                        style={{ display:'block', transform:`translate(${offset.x}px, ${offset.y}px) scale(${scale})` }}
                        onLoad={()=>setImgReady(true)}
                        onError={()=>{ setImgReady(false); message.warning('Image not available for this query'); }}
                        alt="Topology"
                      />
                    </>
                  )}
                </div>
              </Card>
            </Col>
            <Col xs={24} lg={10}>
              <Card title="Devices on Path">
                <DevicesTable rows={devices} onTag={onTagRow}/>
              </Card>
            </Col>
          </Row>

          <Collapse items={[
            { key:'json', label:'Raw Results (JSON)', children:<pre className="json">{json ? JSON.stringify(json, null, 2) : 'No results yet.'}</pre> }
          ]} />

          <ApprovedNetworksCard onChanged={refreshDevicesFromForm}/>

          <TagModal
            open={tagOpen}
            onCancel={()=>setTagOpen(false)}
            prefillCidr={tagPrefill.cidr}
            prefillTags={tagPrefill.tags}
            onSaved={async ()=>{
              setTagOpen(false);
              message.success('Tags saved');
              await refreshDevicesFromForm();
            }}
          />
        </Space>
      );
    }

    /* ===== App Shell ===== */
    function AppShell() {
      const [isDark, setIsDark] = useState(false);
      return (
        <ConfigProvider theme={{ algorithm: isDark ? theme.darkAlgorithm : theme.defaultAlgorithm }}>
          <Layout style={{ minHeight:'100%' }}>
            <HeaderNav currentPath={location.pathname} onToggleTheme={()=>setIsDark(v=>!v)} isDark={isDark}/>
            <Content>
              <TopologyPage/>
            </Content>
            <Footer style={{ textAlign:'center' }}>Tufin Topology • Ant Design UI</Footer>
          </Layout>
        </ConfigProvider>
      );
    }

    // Basic global error surfacing
    window.addEventListener('error', (e)=>console.error('GlobalError:', e.message));
    window.addEventListener('unhandledrejection', (e)=>console.error('UnhandledRejection:', e.reason));

    ReactDOM.createRoot(document.getElementById('root')).render(<AppShell />);
  </script>
</body>
</html>
